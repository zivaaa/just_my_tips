# Dagger2 (№1)

Dagger2 - фреймворк реализующий принципы ведрения зависимостей (DI / Depency Injection). 

- Для его использования надо писать специальные аннотации;
- На основе аннотаций он будет генерировать статические классы, поэтому чтобы увидеть результат надо запускать компиляцию проекта;

Вот небольшой пример использования в Android на Kotlin.

1. Добавим зависимости и настройки в build.grandle

``` 
...
apply plugin: 'kotlin-kapt'
...


android {
	...
}

dependencies {
    def daggerVersion = "2.19"

	...

    implementation "com.google.dagger:dagger:$daggerVersion"
    kapt "com.google.dagger:dagger-android-processor:$daggerVersion"
    kapt "com.google.dagger:dagger-compiler:$daggerVersion"
}

```

2. Создадим пару классов Circle и Square которые релизуют общий интрефейс Shape, снабдив их конструкторы аннотацией ``` @Inject ```. 

``` 

import dagger.Component
import javax.inject.Inject

interface Shape {
    fun area() : Float
}

class Square @Inject constructor() : Shape {
    override fun area() : Float {
        return 15f
    }
}

class Circle @Inject constructor() : Shape {
    override fun area() : Float {
        return 35f
    }
}
```

2.1. Добавим класс который зависит от Shape и Square, снабдив его такой же аннотацией. 
Именно процесс создания этого класса мы и будем упрощать с помощью Dagger2.

``` 

class Calculator @Inject constructor(
    var square : Square,
    var circle : Circle
) {

    fun sumArea() : Float {
        return square.area() + circle.area()
    }
}

```

2.2. Создадим интрефейс CalculatorComponent с аннотацией ``` @Component ``` - этот интрефейс и будет реализовывать Dagger2, 
а мы уже эту реализацию используем чтобы получить готовый Calculator со всеми зависимостями.

``` 
@Component
interface CalculatorComponent {
    fun getCalculator() : Calculator
}
```

2.3. Пока еще ничего не произошло и работать не с чем. 
Чтобы dagger2 на основе наших классов и интерфейсов построил, что-то с чем можно работать надо скомпилировать приложение.
Можно запустить команду ``` run ``` или запустить построение apk ``` Build -> Build Bundle(s) / APK```, после чего появится новый сгенерированный класс наподобие такого:

``` 
// Generated by Dagger (https://google.github.io/dagger).

public final class DaggerCalculatorComponent implements CalculatorComponent {
  private DaggerCalculatorComponent(Builder builder) {}

  public static Builder builder() {
    return new Builder();
  }

  public static CalculatorComponent create() {
    return new Builder().build();
  }

  @Override
  public Calculator getCalculator() {
    return new Calculator(new Square(), new Circle());
  }

  public static final class Builder {
    private Builder() {}

    public CalculatorComponent build() {
      return new DaggerCalculatorComponent(this);
    }
  }
}

```

3. Ну а теперь используем его в активити:

``` 
	//...
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        findViewById<Button>(R.id.fireBtn).setOnClickListener {
            val component = DaggerCalculatorComponent.create()
            Toast.makeText(this, "data from component : ${component.getCalculator().sumArea()}", Toast.LENGTH_SHORT).show()
        }
    }
	//...
```

